\section{Using policy languages to specify access conditions}
\label{sec:sota_policies}

Policy languages have been used in the last decades to specify information regarding the usage of data, e.g., to represent licenses associated with datasets or software usage.
As such, they seem perfectly aligned with the goal of representing the conditions to access data on the Web, whether being preferences set by data subjects or access requests from other entities.
In addition, if used together with privacy and data protection-specific terms, e.g., coming from the ontologies described in the previous Section, they can be used to model legally-aligned access control policies.

In the following Sections, the criteria used to analyse each specified policy language are described, as well as a description of each identified language.

\subsection{Criteria for analysis}
\label{sec:sota_policies_criteria}

Each solution is accompanied by an introductory summary of the language, detailing its primary contributions, followed by an overview of its core elements.
Additionally, where applicable, specific examples of use cases employing the language are provided, along with details on any derived implementations, including information on available reasoners that use it.
The dependencies on prior existing works are also noted when outlined in the literature.
Table~\ref{tab:resources-policy-languages} presents a concise description of the policy languages detailed in the following Sections, along with details about the creators of the resources, version number, publication date, and the most recent update date.
The solutions were examined chronologically based on their publication date, followed by their last update date.
Figure~\ref{fig:lang-dependency-graph} depicts a dependency graph illustrating the relationships between languages, their dependencies, and subsequent developments.

\begin{table}[ht]
\centering
\caption{Brief description of the policy languages described in Section \ref{sec:sota_policies_description}.}
\label{tab:resources-policy-languages}
\resizebox{\textwidth}{!}{%
\begin{tabular}{c||c|c|c|c|c}
Abbreviation (Section) & Full Name & Creators & Version & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}} Date of \\ publication \end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}} Last \\ update \end{tabular}} \\
 \hline\hline
 P3P (\ref{sec:p3p}) & Platform for Privacy Preferences & Cranor et al. & 1.0 & 1998 & 2010 \\
 \hline
 ODRL (\ref{sec:odrl}) & Open Digital Rights Language & Iannella et al. & 2.2 & 2001 & 2019 \\
 \hline
 XPref (\ref{sec:xpref}) & XPath-based Preference Language & Agrawal et al. & - & 2003 & - \\
 \hline
 AIR (\ref{sec:air}) & Accountability In RDF & Khandelwal et al. & - & 2007 & 2009 \\
 \hline
 S4P (\ref{sec:s4p}) & SecPAL for Privacy & Becker et al. & - & 2009 & 2010 \\
 \hline
 POL (\ref{sec:pol}) & Privacy Option Language & Stefan Berthold & - & 2010 & 2013 \\
 \hline
 PPO (\ref{sec:ppo})& Privacy Preference Ontology & Sacco and Passant & - & 2011 & 2013 \\
 \hline
 LegalRuleML (\ref{sec:legalruleml}) & LegalRuleML Core Specification & Palmirani et al. & 1.0 & 2012 & 2021 \\
 \hline
 A-PPL (\ref{sec:appl}) & Accountable Policy Language & Azraoui et al. & - & 2013 & 2016 \\
 \hline
 P2U (\ref{sec:p2u}) & Purpose-To-Use & Iyilade and Vassileva & - & 2014 & - \\
 \hline
 SPL (\ref{sec:special}) & SPECIAL Usage Policy Language & Bonatti et al. & 1.0 & 2017 & 2019 \\
 \hline
 DPF (\ref{sec:dpf}) & Declarative Policy Framework & Martiny et al. & - & 2018 & 2020 \\
 \hline
 LPL (\ref{sec:lpl}) & Layered Privacy Language & Gerl et al. & - & 2018 & 2019 \\
\end{tabular}}
\end{table}

\begin{figure}
    \caption{Privacy-related policy languages dependency chart.}
    \label{fig:lang-dependency-graph}
    \centering
    \includegraphics[width=\textwidth]{figures/chapter-2/languages.png}
\end{figure}

Moreover, the following criteria were used to analyse existing research on semantic policy languages:
\begin{enumerate}
    \item[(C1)] Ability to model deontic concepts, e.g., permissions, prohibitions, obligations.
    \item[(C2)] Ability to model GDPR concepts, such as the privacy terms in Table \ref{tab:GDPR_privacy_terms}.
    \item[(C3)] Existence of taxonomies of terms to populate policy conditions.
    \item[(C4)] Existence of mechanisms to assist with compliance.
    \item[(C5)] Resource is maintained/continues to be actively developed.
    \item[(C6)] Existence of an open and accessible specification.
\end{enumerate}

The outcomes of this comparative analysis will be provided in Section~\ref{sec:sota_policies_analysis} and systematised in Table~\ref{tab:languagesComparison}.

\subsection{Semantic policy languages for access control}
\label{sec:sota_policies_description}

This Section's main goal is to describe existing policy languages related to privacy, delineating the structure and information offered by each language.
Additionally, their compatibility with the GDPR is assessed, focusing on their ability to describe the provisioned rights and obligations.
Moreover, Table~\ref{tab:resources-policy-languages} provides an overview of these languages and collects information about the creators of the resources, their versions, the date of publication, and the date of the last known update.
Said languages are then analysed in chronological order regarding the date of publication and a dependency graph is presented in Figure~\ref{fig:lang-dependency-graph}.

To complement the description of the languages presented in this Section, additional documentation and resources were published on a Web page\footnote{Available at \url{https://w3id.org/people/besteves/phd/sota/languages}. Its public repository can be consulted at \url{https://w3id.org/people/besteves/phd/sota/repo} for further improvement when new solutions appear.}, including diagrams and code examples.

\subsubsection{P3P}
\label{sec:p3p}

\cite{cranor_platform_2002} introduced the Platform for Privacy Preferences (P3P) language as a standard for Web services to disclose their privacy practices in a machine-readable format.
This facilitated user agents in easily interpreting these practices and notifying users about decisions based on them. 
However, despite enabling users to be informed about the privacy policies of Web pages, these mechanisms do not ensure that the pages are actively adhering to these policies, as P3P lacks enforcement capabilities.
Therefore, the P3P vocabulary was designed not to comply with a specific regulation but rather to specify the practices of single Web pages.

The primary contributions of the P3P specification include a data schema for outlining the data intended to be collected by the Web page, a standardised set of purposes, data categories, and recipients, and an XML standard for defining privacy policies.
P3P policies consist of both general assertions and specific statements, the latter being related only to certain types of data.
General assertions encompass the legal entity applying the policy and informational elements related to access, disputes, and remedies.
The access element indicates whether the Web page allows access to the data it gathers and the disputes element outlines a process for resolving privacy-related disputes, while the remedy element details potential solutions in the event of a policy breach.
Additionally, each P3P statement consists of a distinct `data group' containing one or more data elements, along with purpose, recipient types, and retention elements.
In this context, P3P outlines a range of purposes relevant to Web-based data processing operations, such as facilitating and supporting the initial activity for which the data was supplied, conducting research and development, or performing data analysis.
%The purpose element is required to include at least one specification of purpose.
The recipient type element can be used to specify who will benefit from the collected data, while the retention element must accurately reflect the policy regarding how long the data will be kept.
Listing~\ref{list:p3p_example} displays a P3P policy that underscores the aforementioned P3P elements.
CatalogExample gathers essential details concerning its users' computer systems, as well as data regarding the pages they visit.
This information serves system administration and research and development purposes and is exclusively utilised by the company and retained for a duration deemed suitable for the specified purposes.

\begin{listing}
\caption{P3P policy extracted from Example 3.1 of the P3P specification~\citep{cranor_platform_2002}, which specifies the privacy policy of CatalogExample.}
\label{list:p3p_example}
\begin{minted}{turtle}
<http://example.com/#forBrowsers> a p3p:Policy ;
    p3p:disclosure <http://example.com/PrivacyPractice.html> ;
    p3p:entity [
        p3p:business.name [ rdf:value "CatalogExample" ] ;
        p3p:business.contact-info.postal.street [
            rdf:value "4000 Lincoln Ave." ] ;
        p3p:business.contact-info.postal.city [
            rdf:value "Birmingham" ] ;
        p3p:business.contact-info.postal.stateprov [ rdf:value "MI" ] ;
        p3p:business.contact-info.postal.country [ rdf:value "USA" ] ;
        p3p:contact.online.email [ rdf:value "catalog@example.com" ] ;
        p3p:contact.telephonenum.intcode [ rdf:value "1" ] ;
        p3p:contact.telephonenum.loccode [ rdf:value "248" ] ;
        p3p:contact.telephonnum.number [ rdf:value "3926753" ] ] ;
    p3p:access p3p:AccessClass-nonident ;
    p3p:statement [
        p3p:purposeAlways p3p:Purpose-admin, p3p:Purpose-develop ;
        p3p:recipientAlways p3p:Recipient-ours ;
        p3p:retention p3p:Retention-stated-purpose ;
        p3p:data [
            rdf:predicate p3p:dynamic.clickstream, p3p:dynamic.http ] ] .
\end{minted}
\end{listing}

P3P was initially developed to articulate policies of Web services, prompting the design of APPEL as an extension to empower users in expressing their preferences~\citep{cranor_p3p_2002}.
Consequently, the utilisation of both languages becomes imperative to align user privacy preferences with service privacy policies.
Furthermore, \cite{bohrer_customer_2000} introduced the CPExchange language, an XML specification facilitating the transfer of customer data across enterprise services, incorporating P3P privacy policies relevant to the exchanged data.
Likewise, EPAL~\citep{ashley_enterprise_2003}, developed by IBM Research\footnote{\url{http://www.research.ibm.com/} (accessed on 16/July/2023)} along with its precursor E-P3P~\citep{ashley_e-p3p_2002}, leveraged P3P statements to align enterprise privacy policies with user preferences.
\cite{li_semantics-base_2006} introduces a declarative data-centric semantic model alongside a succinct syntax for P3P policies, facilitating the representation of the relationship between various P3P elements.
The primary aim of this language is to articulate policies in a manner that can be uniformly interpreted and represented across diverse user agents.
Extending this semantic foundation, the authors put forward SemPref, a preference language that considers the significance of the privacy policy rather than its syntactic form.

The P3P 1.0 Specification achieved W3C Recommendation status on April 16, 2002.
Nonetheless, its adoption was restricted as it requires acceptance from both Web services and users.
Furthermore, there has been no protocol established for these P3P policies to accurately reflect the privacy practices of Web pages.
While this specification did attain W3C recommendation status, its failure to gain widespread adoption rendered it obsolete by 2018.
Nonetheless, the significance of P3P remains considerable, as its inception and utilisation marked a pioneering endeavour in the realm of machine-readable privacy languages. 
Consequently, the primary lessons derived from this language pertain to the necessity of establishing a formal semantics capable of delineating both data subject and controller policies, which accurately reflect their data preferences and practices, and the need for tools that effectively enforce the outlined policies.

\subsubsection{ODRL}
\label{sec:odrl}

The ODRL Vocabulary \& Expression 2.2~\citep{iannella_odrl_2018} gained W3C Recommendation status in February 2018, developed by the Permissions \& Obligations Expression Working Group, with its initial version launched back in 2001.
Its primary objective was to establish a language capable of translating natural language policies into machine-readable formats, specifying details regarding permissions, prohibitions, and obligations pertaining to an asset.
This vocabulary stems from the consolidation of previous efforts undertaken by the ODRL CG, encompassing the ODRL V2.1 Common Vocabulary, the ODRL V2.1 XML Encoding, the ODRL V2.1 Ontology, and the ODRL V2.1 JSON Encoding.
Ongoing maintenance of the ODRL's standards and specifications are supported by the ODRL CG.

ODRL includes two vocabularies for the description of policies: the ODRL Core Vocabulary and the ODRL Common Vocabulary.
The primary class within ODRL's Core Vocabulary is the `policy' concept, facilitating the identification of a specific policy through its unique identifier.
Within each policy, there may exist multiple rules -- an abstract class that outlines the shared characteristics of permissions, prohibitions, and duties.
These rule types serve to declare whether a particular action, e.g., over as asset, is permitted, prohibited, or obligatory.
Additionally, permissions might also be linked with duties that must be fulfilled for said permissions to be active.
Furthermore, rules undergo further refinement through the usage of constraints, which specify the circumstances under which the rule applies, e.g., a particular permission remains valid until the conclusion of 2024.
The ODRL Vocabulary also outlines a collection of 49 actions, nine of which are imported the Creative Commons (CC) vocabulary.
The entities, or parties, involved (which can encompass a group of individuals, an organisation, or an agent) are responsible for enforcing the rules and may assume various roles contingent upon their relationship with the asset, e.g., the entity issuing the rule adopts the assigner role, whereas the recipient of the rule assumes the assignee role.
An asset, on the other hand, refers to an identifiable resource, such as data, software, services, or a combination thereof, that is subject to a rule.
The ODRL Common Vocabulary further delineates subclasses of policies, roles played by the involved parties, taxonomies of use and transfer actions for rules, and a variety of constraint operands, such as temporal, spatial, or sector-specific.
Of particular significance concerning the GDPR is the privacy policy subclass regarding assets containing personal data. 
Consequently, privacy policies implementing the ODRL language must specify to the involved parties the manner in which data is utilised, as well as with whom and for what purpose.
Listing~\ref{list:odrl_example} provides an implementation of an ODRL privacy policy that underscores the aforementioned elements, including a duty for the assignee to be allowed to use the data and a consequence in case they do not.

\begin{listing}
\caption{ODRL \texttt{Privacy} policy.}
\label{list:odrl_example}
\begin{minted}{turtle}
<http://example.com/privacy-policy> a odrl:Privacy ;
    odrl:uid <http://example.com/privacy-policy> ;
    odrl:permission [
        odrl:target <http://example.com/beatriz/contacts> ;
        odrl:assignee <http://example.com/beatriz> ;
        odrl:assigner <http://example.com/company-a> ;
        odrl:action odrl:use ;
        odrl:duty [
            odrl:action odrl:obtainConsent ;
            odrl:consentingParty <http://example.com/beatriz> ;
            odrl:consequence [
                odrl:assigner <http://example.com/company-a> ;
                odrl:action odrl:delete ] ] ] . 
\end{minted}
\end{listing}

ODRL's representational capabilities exhibit some limitations, as highlighted by~\cite{kebede_critical_2020}, particularly regarding the portrayal of delegation, the various semantics utilised for expressing duties, and the management of conflicts.
Nevertheless, efforts such as those described by~\cite{fornara_operational_2018, fornara_using_2019} are underway to formalise the semantics of ODRL policies.

ODRL was applied in various contexts, including its usage by working groups within the Open Mobile Alliance SpecWorks\footnote{\url{https://www.omaspecworks.org/} (accessed on 18/July/2023)} and by the IPTC Rights Expressions WG for the RightsML Standard\footnote{\url{https://www.iptc.org/std/RightsML/2.0/RightsML_2.0-specification.html} (accessed on 18/July/2023)}.

\subsubsection{XPref}
\label{sec:xpref}

% still needs to be evaluated
\cite{agrawal_xpref_2005} established XPref as an alternative to APPEL, which only allows for the definition of P3P policies that are unacceptable for the user.
XPref resorts to XPath (XML Path Language) 1.0 and 2.0 expressions to replace APPEL rules, making the preferences formulation more precise and less error-prone.
XPath 1.0, by \cite{clark_xml_1999}, and XPath 2.0, by \cite{berglund_xml_2010}, are W3C Recommendations since November 16th, 1999, and December 14th, 2010, respectively, although no further maintenance will be performed to these specifications since later versions exist and have achieved the Recommendation statute.
XPath's main goal is to provide a way to navigate through the hierarchical elements present in an XML document.
To accomplish this task, XPath treats an XML document as a tree of nodes and an XPath expression, when applied to the document, establishes the ordered sequence of the nodes to produce a compact path notation.
The path is then comprised of expressions that return nodes, such as root, element, text, attribute, namespace, processing instruction or comment nodes.

XPref was designed so that its rules can not only identify combinations of P3P elements which make a policy unacceptable, according to the user's preferences but also verify that the presented elements are specified as acceptable.
XPref manages these goals maintaining the APPEL syntax and semantics and its top classes, \textbf{ruleset} and \textbf{rule}.
However, the rule bodies are replaced by XPath expressions since P3P policies are XML documents and thus can be easily matched with the XPath-based rules.
These expressions are specified by adding a \textit{condition} attribute to the rule, which is responsible for triggering the rule when the XPath expression provides a non-empty outcome.
Thus with XPref rules, using the \textit{behavior} attribute, it is possible to establish a preference to block or allow services according to the P3P policy elements, e.g. purposes and recipients, specified on the \textit{condition} attribute.

\subsubsection{AIR}
\label{sec:air}

\cite{hitzler_analyzing_2010} implemented Accountability in RDF (AIR), a declarative language to make assertions of facts and addition of rules, based on N3Logic \citep{berners-lee_n3logic_2008}, that supports rule nesting, rule reuse, and automated explanations of rule-based actions performed by the AIR reasoner.
These explanations are customizable and, since they can be a source of sensitive information such as Personally Identifiable Information (PII), can be used to provide privacy, for instance, to hide actions performed under certain rules.

N3Logic is an extension of the RDF data model that aims at expressing logic rules on the Web so that the same language is used for data and logic.

AIR builds on N3Logic's built-in functions, nested graphs and contextualized reasoning, allowing the AIR rules to adopt the usage of graphs as literal values, universally or existentially quantified variables in graphs and built-in functions or operators expressed as RDF properties.

Each rule has a unique IRI, an HTTP URI, so that it is part of the linked data cloud and can be reused.
These rules are defined using the following structure: \textbf{air:if} \textit{condition}; \textbf{air:then} \textit{then-actions}; \textbf{air:else} \textit{else-actions}.
The action instances can be annotated through the \textbf{air:description} properties.
These annotations are then incorporated by the AIR reasoner in its justifications and can be used to hide PIIs present in the rule set.
Also, the rules graph format allows for the nesting of rules within the same rule set, thus providing a way to segment the conditions stated by the rule in order to only expose part of them in the justifications.

\subsubsection{S4P}
\label{sec:s4p}

S4P (SecPAL for Privacy), developed by \cite{becker_framework_2009, becker_s4p_2010}, is a language framework to express users' privacy preferences and Web services data handling policies.
This language was developed by Microsoft Research\footnote{\url{https://www.microsoft.com/en-us/research/} (accessed on 16 March 2024)} and it is an extension of the company's previous work, SecPAL, to define the handling of PII.

SecPAL \citep{becker_design_2007} is an extensible and decentralised authorisation language, developed to express policies and better disclose expressiveness features such as delegation, domain-specific constraints, and negation.
An authorisation policy is composed of a group of assertions that have an issuer, that vouches for the assertion, the collection of conditional facts and constraints related to times, dates or addresses.
Then, when requesting access to the service, this request is transformed into a series of queries, which are checked against the clauses defined to represent the system's policy, so that the decision is made.
S4P extends SecPAL to treat granted rights and required obligations as assertions and queries and, based on these, a satisfaction checking algorithm is defined for the disclosure of PII between users and data-collecting services.
Therefore, services express data-handling policies as SecPAL queries, defining what is going to be their behaviour in relation to the users' PII, and the users express their preferences as SecPAL assertions, making precise what the services are permitted to do and what their obligations are towards the users' PII.
The satisfaction algorithm then checks if the services data collecting activities match the behaviours permitted by the users and if the obligations defined on the users' preferences are respected by the services' policies.
If the outcome of this algorithm is positive, meaning the service's policy satisfies the preferences of the user, the service can proceed with its data-collecting activities.
S4P also defines a data disclosure protocol to ensure that the users' preferences are regarded when their data is provided to third parties.
This protocol only allows the disclosure of the user's PII if the service's policies satisfy the preferences of the user while allowing the disclosure and if the policies of the third parties are aligned with the preferences of the user.

In addition to having an XML schema for implementations, S4P has a human-readable and unambiguous syntax that allows it to be used in other applications.
Listing \ref{list:s4p_example} presents S4P syntax through an example where the user, Alice, specifies her privacy preferences regarding the collection of her email address. Alice allows eBooking services to use her email address for sending confirmations and newsletters, and for statistical purposes. Alice also allows the booking services to forward her email address to trusted partners, which they can define for themselves, and she is only considering using registered services which will delete her email address within a month.

\begin{listing}
\caption{S4P example adapted from \cite{becker_framework_2009}, which specifies the privacy preferences of Alice regarding the collection of her email address by eBooking services.}
\label{list:s4p_example}
\begin{minted}[escapeinside=||]{python}
Alice says x may use Email for p if
    x is a eBookingService,
    where p |$\in$| {Confirmation, Newsletter, Stats}
Alice says x may send Email to y if
    x is a eBookingService,
    y is a TrustedPartner
Alice says x can say y is a TrustedPartner if
    x is a eBookingService
Alice says |$\langle$|Service|$\rangle$| is a RegisteredService|$?$| |$\wedge$|
    |$\exists$|t (|$\langle$|Service|$\rangle$| says |$\langle$|Service|$\rangle$| will delete Email within t|$?$| |$\wedge$| t |$\leq$| 30 days|$?$|)
\end{minted}
\end{listing}

\subsubsection{POL}
\label{sec:pol}

The Privacy Option Language (POL) was developed by \cite{berthold_privacy_2013} in order to define privacy contracts between data controllers and data subjects, based on the concepts of financial option contracts and respective data disclosure agreements.
Its framework applies the data minimization principle by automatically transforming privacy contracts into a canonical form.
This canonical form allows the differences among contract compositions to be normalized and so contracts have a similar semantic structure.

In POL, each privacy contract is focused on defining the rights and obligations regarding data disclosure.
As this language emerged in the financial context, contract formulations are mainly based on obligations, unless there is no trivial formulation of them.
To implement these formulations, POL resorts to several modules that can also be extended.
The main components defined by the language are the \textbf{syntax} module, the data-related modules for \textbf{personal data}, \textbf{purpose}, \textbf{observable} values and \textbf{time}, and the semantics modules  for \textbf{management} and \textbf{human readability}.
The syntax module contains the language primitives to define the POL contracts' canonical form. 
The data modules can then be hooked to the contracts through data support structures as simple as an attribute-value pair, such as \textit{(eye colour, brown)}, or as complex as tree-like data organizations.
Specifically, the observable module specifies comparison and Boolean operators, which are available in the contract execution environment, to evaluate data retention periods for instance.
The time component is useful to formalise distinct time models, i.e., event-driven, discrete or continuous time.
The semantic modules, for management and human readability, are used to manage changes in observables, i.e. when time elapses, and to translate POL contracts into natural language, respectively. 
Listing \ref{list:pol_example} presents a list of POL contract examples: (1) contract $c_{company}$, that settles the immediate usage of personal data $a_1$ for purpose $p_1$, describes the rights and obligations of the institution that receives the data; (2) $c_{user}$, the negation of $c_{companyA}$, belongs to the user that discloses the data; (3) $c_A$ represents a contract in which a company has the right to use data $a_A$ for purpose $p_A$ at time $t_A$ or not use it at all (represented by the $zero$ contract); and (4) $c_B$ in which a company may or may not use data $a_B$ for purpose $p_B$ until $t_B$ and has the obligation to delete it after the $t_B$ deadline.

\begin{listing}
\caption{POL contract examples adapted from \cite{berthold_towards_2011}.}
\label{list:pol_example}
\begin{minted}[escapeinside=||]{text}
(1) |$c_{company}$| = data |$a_1$| |$p_1$|
(2) |$c_{user}$| = give |$c_{company}$|
(3) |$c_A$| = when (at |$t_A$|) (data |$a_A$| |$p_A$| |`or'| zero)
(4) |$c_B$| = until (at |$t_B$|) (data |$a_B$| |$p_B$| |`or'| zero) 
\end{minted}
\end{listing}

This language was developed on the PETWeb II project, with the main goal of addressing societal questions in the domain of electronic identifiers.
The online documentation provides application scenarios for the usage of POL.

\subsubsection{PPO}
\label{sec:ppo}

As privacy is one of the challenges of the open data era, it is of the utmost importance to define who has access to what, especially in the context of the Web.
In this light, the Privacy Preference Ontology (PPO) \citep{sacco_privacy_2011} proposes to represent users' privacy preferences for the restriction or permission of access to specific RDF data within a document.
This ontology extends the Web Access Control (WAC) specification, a taxonomy for detailing access control privileges that uses Access Control Lists (ACLs) to determine which data users have access to.
Its fundamental concepts are the \textbf{Read} and \textbf{Write} terms, as well as the \textbf{Control} privilege to specify and modify the ACL, although this control can only be exercised to define who can access the full RDF document and not to specify access restrictions over specific data within the document.
Therefore, PPO's main goal is to offer highly granular mechanisms to regulate users' access to specific data represented as Linked Data, building on the work previously carried out by the WAC.

PPO's restriction abilities apply to particular statements, to groups of statements (such as RDF graphs) and to resources, that can be particular subjects or objects within statements.
The type of restriction must also be defined, as the user can either have read, write or both privileges to the data.
Through the defined \textbf{hasCondition} property, certain conditions can be set to define privacy preferences in relation to specific resources, instances of particular classes or properties or even to specific values of properties.
The access space should also be defined so that the requirements are met by the users to access certain resources.
These requirements can be verified through a SPARQL ASK query that contains all attributes and properties that must be met by the users.

Particularly, the same authors focused on developing a specific tool for the Semantic Web domain, a privacy preference manager \citep{sacco_privacy_2011b} based on PPO with the target of providing users with a way to specify their particular privacy choices and regulating access to their data depending on profile characteristics such as relationships, interests or other common features.
This ontology can be used to cover any social data that is modelled in RDF or through RDF wrappers that can be applied to any major Web page through their Application Programming Interface (API).

\subsubsection{LegalRuleML}
\label{sec:legalruleml}

LegalRuleML is a rule interchange language applied to the legal domain, defined by the OASIS\footnote{Non-profit organization focused on open standards for cloud, security and other areas, \url{https://www.oasis-open.org/}} LegalRuleML Technical Committee, which achieved the OASIS Standard status in August 2021 \citep{palmirani_legalruleml_2021}.
It is an XML-schema specification that reuses and extends RuleML concepts and syntax -- RuleML is an XML language for rule representation \citep{boley_specification_2017} -- with formal features to represent and reason over legal norms, guidelines and policies.
LegalRuleML's main features include the use of multiple semantic annotations to represent different legal interpretations, the modelling of deontic operators, the temporal management of rules, the authorial tracking of rules and a mapping to RDF triples. 

Thus, the core elements of a LegalRuleML document are the \textbf{metadata}, the \textbf{context} and the \textbf{statements}.
The metadata section contains information about the \textbf{legal source} of the norms, to ensure that they are connected with the legal text statements that specify them, and also about the \textbf{actors} and the \textbf{roles} they execute in relation to the established rules, about the \textbf{jurisdiction} and the \textbf{authorities} that create, endorse and enforce the rules and information about the \textbf{temporal parameters} that define the period of validity of the rules.
The context element allows the expression of alternative interpretations of the source of the rule, which can change over time or according to jurisdiction, and also enables the representation of the \textbf{association} element, which connects the legal sources with the rules.
The statements section encompasses the formalization of the norms, including the expression of constitutive and prescriptive statements, overrides statements or violation-reparation statements.
The \textbf{constitutive} rules represent the definitions present in the legal documents, while the \textbf{prescriptive} rules encode the deontic specifications.
\textbf{Override} statements can be used to deal with incompatible rules and \textbf{violation and reparation} statements formalize the penalties applied to norm' breaches.

Particularly, \cite{palmirani_modelling_2018} proposed a framework which uses LegalRuleML, Akoma Ntoso and the PrOnto ontology (described in Section \ref{sec:pronto}) to model GDPR rules and check for compliance.
% Listing \ref{list:legalruleml_example} presents an extract of LegalRuleML's formalisation of GDPR\footnote{The formalisation of GDPR's provisions in LegalRuleML is available at \url{https://raw.githubusercontent.com/dapreco/daprecokb/master/gdpr/rioKB_GDPR.xml}}, in particular of Article 19.

% \begin{listing}
% \caption{Extract of LegalRuleML formalisation of GDPR's Article 19.}
% \label{list:legalruleml_example}
% \begin{minted}{xml}
% <lrml:LegalReference refersTo="gdprC3S3A19P1ref" 
%     refID="GDPR:art_19__para_1" />
% <lrml:Associations key="ascs1">
%     <lrml:Association>
%         <lrml:appliesSource keyref="#gdprC3S3A19P1ref" />
%         <lrml:toTarget keyref="#statements103" />
%     </lrml:Association>
% </lrml:Associations>
% <lrml:Context>
%     <lrml:appliesAssociations keyref="#ascs1"/>
%     <lrml:inScope keyref="#statements103Formula1" />
%     <lrml:inScope keyref="#statements103Formula2" />
%     <lrml:inScope keyref="#statements103Formula3" />
%     <lrml:inScope keyref="#statements103Formula4" />
% </lrml:Context>
% <lrml:Statements key="statements103">
%     <lrml:ConstitutiveStatement key="statements103Formula1">
%       <ruleml:Rule closure="universal">
%         <ruleml:if>
%           <ruleml:Exists>
%             <ruleml:Var key=":a1">a1</ruleml:Var>
%             <ruleml:Var key=":eor">eor</ruleml:Var>
%             <ruleml:Var key=":enr">enr</ruleml:Var>
%             <ruleml:Var key=":edp">edp</ruleml:Var>
%             <ruleml:Var key=":w">w</ruleml:Var>
%             <ruleml:Var key=":z">z</ruleml:Var>
%             ...
%             <ruleml:And>
%               <ruleml:Atom>
%                 <ruleml:Rel iri="rioOnto:RexistAtTime" />
%                 <ruleml:Var keyref=":a1" />
%                 <ruleml:Var key=":t1">t1</ruleml:Var>
%               </ruleml:Atom>
%               <ruleml:Atom keyref=":A2570">
%                 <ruleml:Rel iri="rioOnto:and" />
%                 <ruleml:Var keyref=":a1" />
%                 <ruleml:Var keyref=":eor" />
%                 <ruleml:Var keyref=":enr" />
%                 <ruleml:Var keyref=":edp" />
%               </ruleml:Atom>
%               <ruleml:Atom>
%                 <ruleml:Rel iri="prOnto:DataSubject" />
%                 <ruleml:Var keyref=":w" />
%               </ruleml:Atom>
%               <ruleml:Atom>
%                 <ruleml:Rel iri="prOnto:PersonalData" />
%                 <ruleml:Var keyref=":z" />
%                 <ruleml:Var keyref=":w" />
%               </ruleml:Atom>
%               ...
%             </ruleml:And>
%           </ruleml:Exists>
%         </ruleml:if>
%         <ruleml:then>
%           <ruleml:Exists>
%             <ruleml:Var key=":t2">t2</ruleml:Var>
%             <ruleml:And>
%               <ruleml:Atom>
%                 <ruleml:Rel iri="rioOnto:RexistAtTime" />
%                 <ruleml:Var keyref=":en" />
%                 <ruleml:Var keyref=":t2" />
%               </ruleml:Atom>
%               <ruleml:Atom>
%                 <ruleml:After>
%                   <ruleml:Var keyref=":t2" />
%                   <ruleml:Var keyref=":t1" />
%                 </ruleml:After>
%               </ruleml:Atom>
%             </ruleml:And>
%           </ruleml:Exists>
%         </ruleml:then>
%       </ruleml:Rule>
%     </lrml:ConstitutiveStatement>
%     <lrml:ConstitutiveStatement key="statements103Formula2">
%       ...
%     </lrml:ConstitutiveStatement>
%     <lrml:ConstitutiveStatement key="statements103Formula3">
%         ...
%     </lrml:ConstitutiveStatement>
%     <lrml:ConstitutiveStatement key="statements103Formula4">
%         ...
%     </lrml:ConstitutiveStatement>
%   </lrml:Statements>
% \end{minted}
% \end{listing}

\subsubsection{A-PPL}
\label{sec:appl}

The Accountable Policy Language (A-PPL), implemented by \cite{azraoui_appl_2014}, has its origin in the A4Cloud\footnote{\url{http://www.a4cloud.eu/}} project, with the objective of applying accountability requirements to the representation of privacy policies.
To accomplish this goal, the A-PPL expands PPL (PrimeLife Policy Language) by taking into account guidelines on notification, data location and retention, and auditability.
PPL by \cite{ardagna_primelife_2009} is an extensible privacy policy language designed within the context of the PrimeLife\footnote{\url{http://primelife.ercim.eu/}} project, based on XACML \citep{parducci_extensible_2013}, an eXtensible Access Control Markup Language which is an OASIS standard for access control policies that has been previously tested to deal with GDPR requirements related to consent \citep{fatema_compliance_2017} and privacy by design \citep{piras_defend_2019}. %updated
PPL's core classes to express an obligation are \textbf{triggers} and \textbf{actions}.
Triggers are events that can be filtered using certain conditions and are connected to an obligation.
These triggers are responsible to fire the data controller's actions, which are executed according to the data subject's authorizations.
However, neither PPL nor XACML have the concepts to cover requirements such as the representation of information related to data location and retention rules or auditability provisions to be in line with data handling regulations such as the GDPR.%updated

A-PPL introduced a role attribute identifier and added the data protection authority role to the ones already modelled by PPL, the data subject, data controller and data processor.
Also, two new triggers to allow or prohibit access to personal data were included.
Duration and region attributes related to a particular data processing purpose are used to enforce data retention and location rules.
A-PPL further extends the PPL notification system to define the recipient and the type of notification to be sent in relation to a particular action.
For auditing purposes, A-PPL added a trigger to monitor the data controller and collect evidence of data-related events which are logged with parameters such as the purpose of the action, the time-stamp or the executed action on the data.
Listing \ref{list:appl_example} presents an example of an A-PPL obligation to notify a data subject in case of a breach. A-PPL's $ActionNotify$ element provides a way to notify data subjects, which is triggered in case of a policy violation or loss of data.

\begin{listing}
\caption{A-PPL example extracted from \cite{azraoui_appl_2014}.}
\label{list:appl_example}
\begin{minted}{xml}
<Obligation>
    <TriggersSet>
        <TriggerOnPolicyViolation/>
        <TriggerOnDataLost/>
    </TriggersSet>
    <ActionNotify>
        <Media>e-mail</Media>
        <Address>data-subject@example.com</Address>
        <Recipients>Data subject</Recipients>
        <Type>Policy Violation</Type>
    </ActionNotify>
</Obligation>
\end{minted}
\end{listing}

\subsubsection{P2U}
\label{sec:p2u}

Purpose-To-Use (P2U), by \cite{iyilade_p2u_2014}, has taken inspiration from P3P to build a policy language for the sharing of user information across different services and data consumers, resting on the principle of purpose of use.
Its main focus is to provide a language for the secondary sharing and usage of data, making sure that the user's privacy is maintained.
It is designed to combine information about the data sharing purpose, its retention time and, in the case the user wants to sell it, the selling price and simultaneously allows the data consumers to negotiate prices and retention periods.

This policy framework involves the interaction of the \textit{users} (the owners of the data), the \textit{data consumers} (services that need the data), \textit{the data providers} (services that collect and share the data) and the \textit{data brokers} (services that monitor the consumers' and providers' activities and execute the negotiations, among other tasks).
The main elements of P2U are the \textbf{policies}, the \textbf{data provider}, the \textbf{user}, the \textbf{purposes}, the \textbf{data consumers}, the \textbf{retention}, the \textbf{data groups} and respective \textbf{data} elements.
Policies are the root element of P2U, and each one needs to have an associated provider, a user and at least one purpose of use.
Each policy should have a name, and optionally an attribute with the path to the human-readable policy, and the name and identifier of the data provider and user to which the policy refers.
A P2U policy can specify more than one purpose for the sharing of data, along with information on how long it can be retained, with whom and the relevant data it applies to.
The data consumer element has the particularity of containing an attribute, \textit{name}, that can be set to 'public' if the data can be shared with any third-party service.
Also, the retention period of the purpose should be defined in days and a \textit{negotiable} attribute can be detailed, which is set to false by default.
The same attribute is available for the data group element.
This component is composed of one or more data elements and each one can have an expiry date, which overrides the retention period, and the possibility of setting an initial price for the data in cases where the user is willing to sell it.
Listing \ref{list:p2u_example} presents an example of a P2U policy for secondary sharing of user's information. In the example, the data provider "FoodIntakeApp" wants to share Jerry's data with the data consumer "MyShopApp" for the purpose of shopping recommendations. The consumer can retain the data for 180 days and negotiate it with the provider.

\begin{listing}
\caption{P2U example extracted from \cite{iyilade_p2u_2014}.}
\label{list:p2u_example}
\begin{minted}{xml}
<POLICY discuri=http://mydatawebsite.com/privacy.html name="ShoppingPolicy">
    <PROVIDER name="FoodIntakeApp" provid="p6528m2" />
    <USER name="Jerry" userid="u1030050503050" />
    <PURPOSE name="Shopping Recommendations" puid="102">
        <CONSUMER name="MyShopApp" consid="c10023" />
        <RETENTION period="180" />
        <DATA-GROUP groupid="g090353" negotiable="TRUE">
            <DATA ref="#dailyfoodintake.food" sell="FALSE" />
            <DATA ref="#dailyfoodintake.quantity" sell="FALSE" />
            <DATA ref="#dailyfoodintake.hungerscale" sell="FALSE" />
        </DATA-GROUP>
    </PURPOSE>
</POLICY>
\end{minted}
\end{listing}

An application scenario where a user allows data sharing between several mobile applications is further specified in an additional publication by the same authors \citep{hutchison_framework_2013}.
However, this implementation does not enforce compliance of the data consumers with the policies defined by the users and does not specify any special treatment for cases dealing with sensitive data.


\subsubsection{SPECIAL}
\label{sec:special}

The EU H2020 SPECIAL (Scalable Policy-awarE linked data arChitecture For prIvacy, trAnsparency and compLiance) project aimed to develop technology that supports today's ongoing struggle between privacy and Big Data innovation, providing tools, for data subjects, controllers and processors, that facilitate the management and transparent usage of such data.
Two vocabularies were produced as outcomes of this project: the SPL (SPECIAL Usage Policy Language) and the SPLog (SPECIAL Policy Log) vocabularies \citep{gangemi_scalable_2018}.

A usage policy represents a set of lawful activities that can be performed in accordance with the data subject's consent.
To specify these in formal terms in compliance with the GDPR, the SPL establishes five core elements: the \textbf{data} that is going to be processed, the \textbf{purpose} of such processing, a description of the \textbf{processing} itself, the \textbf{storage} information and the \textbf{recipients} of the processing results.
The data storage element needs two attributes to be instantiated, as both the location and the duration of the storage need to be defined.
So, in mathematical terms, the usage policy is a five-element tuple, composed of instantiations of the five core classes, that specifies an authorized operation.
A general usage policy can then be defined with a union of authorized operations.
The vocabularies designed to specify each of the elements on the SPL are based on previous privacy-related ontologies, such as ODRL, for the processing terms\footnote{\url{https://specialprivacy.ercim.eu/vocabs/processing\#}}, and the P3P, for the data categories\footnote{\url{https://specialprivacy.ercim.eu/vocabs/data\#}}, recipients\footnote{\url{https://specialprivacy.ercim.eu/vocabs/recipients\#}}, purposes\footnote{\url{https://specialprivacy.ercim.eu/vocabs/purposes\#}} and storage duration\footnote{\url{https://specialprivacy.ercim.eu/vocabs/duration\#}} and location\footnote{\url{https://specialprivacy.ercim.eu/vocabs/locations\#}}.
The vocabularies can be further extended by introducing new sub-classes to its terms \citep{bonatti_policy_2018}.
Listing \ref{list:spl_example} presents an example where the auxiliary vocabularies are extended with new terms to create a usage policy (ex:HeartRate as a subclass of the personal data class svd:Health, ex:Profiling as a subclass of the processing term svpr:Analyze and ex:Recommendation as a subclass of the purpose svpu:Marketing). In this policy, heart rate and location data are used for user profiling with the purpose of creating recommendations, while the data is stored indefinitely in the servers of the data controllers in the EU and can be released to any recipients.

\begin{listing}
\caption{SPL general usage policy extracted from \cite{bonatti_special_2019}.}
\label{list:spl_example}
\begin{minted}{text}
ObjectIntersectionOf(
    ObjectSomeValueFrom( spl:hasData
        ObjectUnionOf( ex:HeartRate svd:Location ))
    ObjectSomeValueFrom( spl:hasProcessing ex:Profiling )
    ObjectSomeValueFrom( spl:hasPurpose ex:Recommendation )
    ObjectSomeValueFrom( spl:hasStorage
        ObjectIntersectionOf(
            ObjectSomeValuesFrom( spl:hasLocation
                ObjectIntersectionOf( svl:OurServers svl:EU ))
            DataSomeValuesFrom( spl:durationInDays
                DatatypeRestriction( xsd:integer
                    xsd:mininclusive "0"^^xsd:integer ))))
    ObjectSomeValueFrom( spl:hasRecipient spl:AnyRecipient ))
\end{minted}
\end{listing}

SPLog was designed to provide a record of the processing events related to the consent actions given by the data owners.
This vocabulary builds upon \textbf{PROV-O} \citep{lebo_prov-o_2013} to have information on the provenance of the log and is in line with the terms developed for the SPL vocabulary.
The main concepts defined by SPLog are the \textbf{log} itself and the actual \textbf{log entries}.
Each log has meta-data attached to it, such as the software agent it belongs to, and log entries that contain information about each event.
The log entries can be from one of two types: policy entries -- related to a consent form and related policy terms -- or data events such as data processing or sharing.
These entries should also contain information about the data subject involved in the event, a description, the event's content itself, time stamps, related data-set and so on.
Therefore these logs can be used to track the provenance of an event.
SPLog uses the SPL vocabulary to instantiate a log entry content.
This vocabulary is easily extendable and allows the grouping of events to promote scalability \citep{kirrane_transparency_2018}.

The SPECIAL framework was implemented in various use-cases in distinct sectors: to build personalized touristic recommendations in collaboration with \textit{Proximus}\footnote{\url{https://www.proximus.be/}}; for traffic alert notifications with \textit{Deutsche Telekom}\footnote{\url{https://www.telekom.com/en}}; with \textit{Thomson Reuters Limited}\footnote{\url{https://www.thomsonreuters.com}} to support anti-money laundering requirements.

\subsubsection{DPF}
\label{sec:dpf}

The Declarative  Policy Framework (DPF) \citep{martiny_protecting_2018, martiny_partial_2020} is being developed by an established team under the DARPA Brandeis programme\footnote{\url{https://www.darpa.mil/program/brandeis}} with the main goal of providing a privacy policy framework based on ontology engineering and a formal shareability theory.
DPF's policy engine builds on the ontology to define policy objects which are used in the development of user interfaces (UIs).
These UIs allow non-technical users to create, validate and manage privacy policies without the need to burden them with the technical formalisms of a policy language.
DPF's engine can also be integrated into systems supporting the management of data requests and other Privacy Enhancing Technologies (PETs).

Therefore, DPF uses a defined ontology as a common data model to specify a particular domain in order to support the definition of permissive and restrictive privacy policies.
Each policy rule corresponds to an allow or disallow statement that should have an identifier and a description, a policy authority, the data requesters to whom the policy applies, and also the affected data and effectiveness time imposed by the policy.
Optionally, in the case of a permissive statement, there is the possibility to define a set of constraints to establish the conditions under which the data can be shared.
The policy authority evaluates whether a certain data request complies with the defined policies.
Hence, each data request must include, in addition to the data being requested, the policy authority that will be consulted to grant or refuse access, and the time of the request.
Then the request follows the policy engine pipeline and if there is a matching rule the engine returns the decision, the identifier and description of the analogous rule and, in the case the request is authorized, the valid conditions in which it is allowed.
Since a single request can trigger multiple policy rules, the engine must be equipped to deal with conflicting decisions.
To achieve this, DPF implements baseline policies and then exceptions are created to define policy rules with higher priority in relation to the data that is being shared.
With this mechanism in place, this privacy framework can override decisions based on detailed constraints.

The ontologies are defined in OWL and can be translated to Flora\footnote{\url{http://flora.sourceforge.net/}}, an object-oriented reasoning system which can be used to reason with policies.
To illustrate this framework, the authors provide a pandemic use case where nation and community policy authorities implement data-sharing policies about their residents and respective health status to monitor the disease's outbreak.
Listing \ref{list:dpf_example} presents an example DPF policy rule based on this use-case, where any national policy authority, $?pa$, allows the nations to share their residents' disease states, $?reqData$, with any response coordinators, $?requester$, at a certain time, $?time$, under certain constraints, $?constr$. The $?polData$ query specifies the connection between the nations and the medical state of its residents and it is constrained by $?constr$, a constraint attached to the $?Resident$ variable. In this constraint, the birthday of the resident is taken into account to subtract from the requested data the residents younger than thirteen.

\begin{listing}
\caption{DPF constrained policy rule extracted from \cite{martiny_protecting_2018}.}
\label{list:dpf_example}
\begin{minted}[escapeinside=||]{text}
@!{NationsAllowConstrainedDiseaseStatesToRCs}
?pa [allow_sa(?requester, ?reqData, ?time, ?constr, ?id, ?descr, 0)] :-
    ?id = "NationsAllowConstrainedDiseaseStatesToRCs"^^\string,
    ?descr = "Nations share disease states w Response Coordinators"^^\string,
    ?pa : NationPolicyAuthority,
    ?requester : ResponseCoordinator,
    ?polData = |$\textdollar$|{ ?pa [nation -> ?Nation],
        ?Nation : Nation [community -> ?Community, name -> ?NationName],
        ?Community : Community [resident -> ?Resident],
        ?Resident : Person [medicalInformation -> ?MedInfo],
        ?MedInfo : DiseaseStatus [state -> ?MedState],
        ?Resident [constraints -> ?constr] },
    ?thirteenYears is 13*365*24*60*60, 
    ?time [subtractTime(?thirteenYears) -> ?latestTime],
    ?constr = [|$\textdollar$|{ 
        ?Resident : Person [birthDate -> ?Birthdate],
        timeBefore(?Birthdate, ?latestTime) }],
    implies_sharing(?polData, ?reqData, ?constr).
\end{minted}
\end{listing}

\subsubsection{LPL}
\label{sec:lpl}

Layered Privacy Language (LPL), implemented by \cite{gerl_lpl_2018}, is a human and machine-readable privacy language which aims to promote the expression and enforcement of GDPR's legal requirements related to data subject's consent, personal data provenance and retention and also to implement privacy-preserving processing activities based on the application of state-of-the-art anonymization techniques. 
Further work by \cite{gerl_critical_2018} focused on improving LPL to be able to fully represent the requirements derived from Articles 12 to 14 of the GDPR, the so-called data subject's `Right to be informed'.

LPL's policy structure is \textbf{purpose-based}, i.e., its core architecture is composed of a set of purposes and each purpose has associated a set of \textbf{data} types being processed and also the \textbf{recipients} of said data.
The purpose element in LPL can be enriched with a human-readable description and also includes a `required' property, which can be used to specify if a certain purpose requires the explicit consent of the data subject, and an `optOut' property, which can be used to imply that the user has to actively deny or accept the purpose.
Data elements can be used to specify which data group the data being processed belongs to and also to classify them as sensitive or explicit.
In parallel with data recipients, other entities can be specified, such as controllers or the data protection officer and, additionally, information regarding the retention period, data subject's rights, legal basis and also description details related to automated decision-making activities can be detailed in LPL policies.
Listing \ref{list:lpl_example} presents an example LPL policy. Company $dr_{C1}$ has a service, with an LPL privacy policy $lpp_{ds_{U1}-dr_{C1}}$, which collects and uses personal information from a user $ds_{U1}$ for the purpose $p_{U1}$ and, optionally, the data collected by the company could be shared with a third party recipient. In this case, a new contract has to be concluded for the data sharing, where company $C1$, $ds_{C1}$, is the data source and the third party $C2$, $dr_{C2}$, is the data recipient. 'Marketing' is the purpose for the processing, $p_{U1}$, of the personal data $\hat{D}_1$, which includes postal code (which is anonymised using the 'Suppression' method) and salary data that has to be deleted 180 days after the completion of the purpose.

\begin{listing}
\caption{LPL policy adapted from \cite{gerl_lpl_2018}.}
\label{list:lpl_example}
\begin{minted}[escapeinside=||]{text}
|$ds_{U1}$|=('U1','Person',|$publicKey_{U1}$|,'DataSource')
|$dr_{C1}$|=('C1','Legal Entity',|$publicKey_{C1}$|,'DataRecipient')
|$ds_{C1}$|=('C1','Legal Entity',|$publicKey_{C1}$|,'DataSource')
|$dr_{C2}$|=('C2','Legal Entity',|$publicKey_{C2}$|,'DataRecipient')
|$lpp_{ds_{U1}-dr_{C1}}$|=('1','LPP1','en','https://company.com/privacy.html',|$\emptyset$|,|$ds_{U1}$|,{|$p_{U1}$|})
|$p_{U1}$|=('Marketing','false','true','Marketing purposes, including newsletters.',{|$dr_{C1}$|,|$dr_{C2}$|},|$r_1$|,pm,|$\hat{D}_1$|)
|$r_1$|=('AfterPurpose','180 days')
|$\hat{D}_1$|={|$d_{postal}$|,|$d_{salary}$|}
|$d_{postal}$|=('postal-code',dGroup,'Number','true','Postal code of the user','QID',am1)
|$am_1$|=('Suppression',{|$ama_1$|,|$ama_2$|,|$ama_3$|,|$ama_4$|},|$\emptyset$|)
|$ama_1$|=('Suppression Replacement','*')
|$ama_2$|=('Suppression Direction','backward')
|$ama_3$|=('Minimum Level','2')
|$ama_4$|=('Maximum Level','4')
|$d_{salary}$|=('salary',dGroup,'Number','true','Monthly salary amount received by the user','Sensitive',|$\emptyset$|)
\end{minted}
\end{listing}

\cite{gerl_privacy_2019} validate this language against an actual privacy policy use-case scenario in the complex healthcare domain to demonstrate its capabilities and limitations in relation to GDPR compliance.
In addition, further work extends LPL with machine-readable privacy icons \citep{gerl_extending_2018} to assess its impact on the speed and accuracy of understanding privacy policies and introduces an LPL Personal Privacy Policy User Interface \citep{gerl_interface_2018}.
This UI has the main goal of representing information related to the contents of privacy policies in order to support data subjects to give free and informed consent, which includes a policy header with a link to the human-readable policy and an overview of the purposes for processing using the aforementioned privacy icons, and a purpose section with an overview of all the purposes mentioned in the privacy policy and details regarding the identity of the controllers, data recipients, retention period and anonymisation methods.

\subsection{Comparative analysis}
\label{sec:sota_policies_analysis}

Using Table \ref{tab:languagesComparison} as a reference, it is possible to compare the policy languages described in Section \ref{sec:sota_policies_description} in relation to their capacity to assist with the representation of GDPR rights and obligations.
In this table, the languages are sorted in descending order by the number of supported criteria, then alphabetically, if necessary, to improve readability.

\begin{table}
\centering
\caption[Comparison of the analysed privacy policy languages.]{Comparison of the analysed privacy policy languages, according to the defined criteria described in Section \ref{sec:sota_policies_criteria}.}
\label{tab:languagesComparison} 
\begin{tabular}{ c||c|c|c|c|c|c}
 & C1 & C2 & C3 & C4 & C5 & C6 \\
 \hline\hline
 LegalRuleML & Yes & Partially & No & Yes & Yes & Yes \\
 \hline
 ODRL & Yes & Partially & Yes & No & Yes & Yes \\
  \hline
 SPL & No & Partially & Yes & Yes & No & Yes \\
 \hline
  A-PPL & Yes & Partially & No & Yes & No & No \\
 \hline
  DPF & Yes & Partially & No & Yes & Unknown & No \\
 \hline
  P3P & No & Partially & Yes & No & No & Yes \\
 \hline
  AIR & No & No & No & Yes & No & Yes \\
 \hline
  LPL & No & Partially & No & Yes & Unknown & No \\
  \hline
 S4P & No & Partially & No & Yes & No & No \\
 \hline
  P2U & No & Partially & No & No & No & No \\
 \hline
 POL & No & Partially & No & No & No & No \\
 \hline
  PPO & No & No & No & No & No & No \\
  \hline
 XPref & No & No & No & No & No & No \\
\end{tabular}
\end{table}

Although these languages do not specifically mention the rights and obligations discussed in Section \ref{sec:def_gdpr}, they can be used to represent a few of the items of information mentioned by them, which is why they are classified as capable of partially representing GDPR concepts and principles (C2 criterion in Table \ref{tab:languagesComparison}).
Therefore, most of the analysed languages can be used to partially model the GDPR representational needs identified in Table \ref{tab:GDPR_privacy_terms}, apart from AIR, PPO and XPref.
Listings \ref{list:p3p_example} to \ref{list:lpl_example} provide examples of how to encode a particular privacy policy aspect for each language identified as capable of partially representing concepts present in GDPR's rights and obligations.

However, only ODRL, SPL and P3P provide taxonomies to populate policies and solely LegalRuleML, ODRL, A-PPL and DPF model deontic concepts such as permissions or obligations.
LegalRuleML, SPL, A-PPL, DPF, AIR, LPL and S4P also mention in their literature the existence of reasoning mechanisms or other tools, which are based on the implemented languages, to assist with compliance, and in some cases access to such tools are provided.
Additionally, only LegalRuleML and ODRL continue to be actively maintained and developed, and only LegalRuleML, ODRL, SPL, P3P and AIR have the resources available for reuse on the Web.

In particular, LegalRuleML and ODRL stand out from other languages as they have the resources to respond positively to a greater number of the established comparison criteria.